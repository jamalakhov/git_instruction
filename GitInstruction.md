![Git log](git-logo.jpg)
<h1>Инструкция по работе с Git</h1>
<h2>Меню</h2>
<ol>
  <li><a href=#1-проверка-наличия-установленного-git>Проверка наличия установленного Git</a></li>
  <li><a href=#2-установка-git>Установка Git</a></li>
  <li><a href=#3-настройка-git>Настройка Git</a></li>
  <li><a href=#4-инициализация-репозитория>Инициализация репозитория</a></li>
  <li><a href=#5-добавление-файла-на-отслеживание>Добавление файла на отслеживание</a></li>
  <li><a href=#6-создание-коммита>Создание коммита</a></li>
  <li><a href=#7-просмотр-коммитов>Просмотр коммитов и перемещение между ними</a></li>
  <li><a href=#8-работа-с-ветками>Работа с ветками</a></li>
  <li><a href=#9-конфликты-слияние-веток-и-их-разрешение>Конфликты слияние веток и их разрешение</a></li>
  <li><a href=#10-игнорирование-файлов>Игнорирование файлов</a></li>
</ol>

## [1. Проверка наличия установленного Git](#)

Перед началом работы убедитесь, что на вашем устройстве установлена система контроля версий **Git**. Для это в терминале выполнить команду `git --version`. Если **Git** установлен, то появится сообщение следующего вида (номер версии может отличаться от примера):

> git version 2.34.1

Если вы видите сообщение, которое похоже на пример выше, то все в порядке и можно приступать к работе. В противном же случае перейдите к [пункту 2](#2-установка-git).

## [2. Установка Git](#)
Загружаем последнюю версию **Git** с [сайта](https://git-scm.com/download) и устанавливаем с настройками по умолчанию.
Если вы работаете под операционной системой *Linux*, то можете осуществить установку **Git**, выполнив следующие команды в терминале:
```
sudo apt update
sudo apt install git
```
После завершения процесса установки убедитесь, что все прошло корректно, повторив команду `git --version`.

Сравните полученный результат с примером из [пункта 1](#1-проверка-наличия-установленного-git).
## [3. Настройка Git](#)
При первом запуске **Git**, после успешной установки, вам необходимо "представиться" в системе контроля версий. Для этого нужно ввести в терминал следующие команды:

```
git config --global user.name "Ваше имя"
git config --global user.email email@example.com
```

Данная настройка необходима для того, чтобы в процессе создания *commit* другие пользователи системы контроля версии знали автора и его почту для связи.

Далее, чтобы убедиться в том, что все прошло успешно, выполните следующую команду в терминале `git config --global -l`.

В терминале вам должны отобразится введенные вами данные в следующем виде:
>user.name=Ваше имя
>
>user.email=Ваша почта

Поздравляю! **Git** настроен и можно приступать к работе.
## [4. Инициализация репозитория](#)
Следующим шагом на пути освоения работы с **Git** является создание репозитория.
Придерживайтесь следующего алгоритма:

1. Создайте папку, в которой будет располагаться ваш будущий проект.
2. С помощью терминала перейдите в созданную папку.
3. Для начала убедитесь, что ваша новая папка не содержит в себе репозитория.
    1. Для этого выполните команду `git status`. Если все хорошо, то вы увидите следующее сообщение: 

        fatal: не найден git репозиторий (или один из родительских каталогов): .git
        
       Можно переходить к следующему шагу.

    2. Если же вы увидели сообщение с текстом: "_Текущая ветка: 'имя_ветки'_", то удалите текущую папку и повторите пункт 1.

4. Выполните в терминале команду `git init`.

Репозиторий инициализирован. Чтобы убедиться в этом выполните команду `git status`. В терминале должен отобразиться следующий текст: "_Текущая ветка: master
Еще нет коммитов_".

Репозиторий инициализирован и готов к отслеживанию файлов.
## [5. Добавление файла на отслеживание](#)
Создайте файл внутри вашей папки.
Выполните команду `git status`. В терминале отобразится следующий результат выполнения:
>Текущая ветка: master
>
>Еще нет коммитов
>
>Неотслеживаемые файлы:
>  (используйте «git add <файл>...», чтобы добавить в то, что будет включено в коммит) 'имя файла'
>
>индекс пуст, но есть неотслеживаемые файлы
(используйте «git add», чтобы проиндексировать их)

Чтобы добавить файл на отслеживание, выполните команду `git add имя_файла`.

Снова выполните команду `git status` для просмотра статуса файла:
>Текущая ветка: master
>
>Еще нет коммитов
>
>Изменения, которые будут включены в коммит:
>(используйте «git rm --cached <файл>...», чтобы убрать из индекса) новый файл: 'имя файла'

Ваш файл успешно добавлен в индекс и можно сделать первый коммит.
## [6. Создание коммита](#)
После добавление файла в индекс можно сделать свой первый коммит (фиксация изменений).

`git commit -m "first commit"`

Параметр `-m` указывает на то, что далее в кавычках следует описание тех изменений, которые мы хотим зафиксировать. Данный параметр обязателен при вызове команды _commit_.
Если сейчас мы запустим команду `git status` то увидим следующий результат:
>Текущая ветка: master
>
>нечего коммитить, нет изменений в рабочем каталоге

Коммит успешно зафиксирован.
## [7. Просмотр коммитов и перемещение между ними](#)
Итак, что мы имеем:
+ **Git** настроен;
+ Репозиторий инициализирован (`git init`);
+ Файл создан и добавлен на отслеживание (`git add`);
+ Первый *commit* зафиксирован (`git commit -m`).

Настало время посмотреть наши **коммиты**. Для этого нужно выполнить команду `git log`.

Результат данного запроса будет выглядеть примерно следующим образом:
>commit хэш-коммита (HEAD -> master)
>
>Author: Ваше имя <Ваша почта>
>
>Date:   Дата и время создания
>
>   Текст коммита

В терминале отобразятся **все** коммиты, которые содержит текущая ветка (в нашем примере это ветка _master_).

Для навигации по коммитам используется команда `git checkout хэш-коммита`.

Так как **хэш** очень длинный, то можно использовать первые 5-6 его символов.

[Данная команда](#git-checkout-хэш-коммита) вернет нам состояние файла, которое было на момент создания этого коммита.

Таким образом, зная хэш коммита, можно переключиться на любой из известных.

Кроме того, существует несколько способов компактного отображения списка коммитов. Один из таких - использование команды `git log --oneline`. В результате выполнения данной команды мы получим следующий вывод в консоль:

![online_log](online.jpg)

Как видим, нам отобразился компактный вариант представления: 7 первых символов хэша и текст коммита.


**ВАЖНО!**

---
При переключении между коммитами обязательно возвращайтесь к самому __актуальному__ коммиту:

`git checkout branch_name`

---

## [8. Работа с ветками](#)
Ранее мы уже рассматривали команды для работы с ветками. Давайте вспомним их, а также добавим новые команды.

1. `git branch` - просмотр всех доступных веток
2. `git branch <branch_name>` - создание новой ветки
3. `git checkout <branch_name>` - переключение на ветку
4. `git switch <branch_name>` - переключения на ветку (поддерживается в Git начиная с версии 2.23)
5. `git checkout -b <branch_name>` - создание новой ветки и переключение на нее
6. `git switch -c <branch_name>` - создание ветки и переключение на нее (начиная с версии Git 2.23)
7. `git switch -` - перемещение на предыдущую ветку
8. `git branch --move <old_branch_name> <new_branch_name>` - переименование ветки
9. `git branch -d <branch_name>` - удаление ветки

Это далеко не весь перечень команд по работе с ветками, а только основные. Начиная с версии 2.23 была добавлена узкоспециальная команда `switch`, которая отвечает только за переключение между ветками, в то время как функционал `checkout` куда более шире. Поэтому рекомендуется в обновленной версии **Git** для переключения между ветками пользоваться именно `switch`.

В общем смысле, механизм работы в разных ветках нужен для того, чтобы локализовать реализацую конкретной задачи от всего проекта, так сказать, создать "черновик", который в дальнейшем мы можем объеденить (слить) с основным проектом.

Поэтому далее мы рассмотрим механизм слияния веток.

Итак, мы создали наш "черновик", наполнили его новым кодом, сохранили изменения и сделали коммиты и теперь настало время объеденить его с основной веткой проекта. Для этого мы сначала перейдем на ветку **в которую** будем "вливать" черновик: `git switch master`.

Далее выполним следующую команду `git merge <branch_name>`, где `branch_name` - имя ветки **из которой** мы переносим изменения.

После успешного слияния можно удалить ветку, **из которой** переносили изменения: `git branch -d <branch_name>`.

Таким образом мы получили актуальное состояние всего проекта после выполнения конкретной задачи в отдельной ветке.

## [9. Конфликты слияние веток и их разрешение](#)
Конфликт слияния веток- достаточно распространенная ситуация, когда над проектом работает несколько человек. Если была изменена одна и та же часть одного и того же файла по-разному в двух объединяемых ветках, **Git** не сможет их чисто объединить и остановит процесс до тех пор, пока вы не разрешите конфликт. В конфликтующие файлы **Git** добавляет специальные маркеры конфликтов, чтобы вы могли исправить их вручную. Чтобы разрешить конфликт, придётся выбрать один из вариантов, либо объединить содержимое по-своему.

## [10. Игнорирование файлов](#)
Часто на практике случаются ситуации, когда далеко не все файлы необходимо отслеживать. Именно для этого был реализован механизм игнорирования файлов. Для этого в корне проекта создается специальный файл **.gitignore** в котором перечисляются файлы, которые необходимо исключить из отслеживания. Например, к таким файлам могу относиться изображения. На примере посмотрим, как игнорировать файлы с расширением *.jpg*.

1. создаем файл *.gitignore*
2. добавляем в файл следующую запись: *\*.jpg*

Симлов (\*) означает, что будут игнорироваться все файлы расширения *.jpg* в не зависимости от имени файла.

